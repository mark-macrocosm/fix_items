<?php

/**
 * Please fix the items marked with "@TODO" in this class
 *
 * Follow the https://www.php-fig.org/psr/psr-2/ coding style guide.
 *
 * One exception to PSR-2: opening braces MUST always be on the same line
 * for classes, methods, functions, and control structures
 */
class Singleton {

    /**
     * Use descriptive multi-line comments for properties and constants
     * Prefix protected and private properties/methods with underscore
     * 
     * @var Singleton
     */
    protected static $_instance;

    /**
     * Use constants for immutable types instead of variables
     * Use descriptive names
     */
    const STRING_A     = 'A';
    const STRING_A_LONG = 'stringA';
    const STRING_B_LONG = 'stringB';
    const STRING_NON_A = '^A';
    const STRING_NON_B = '^B';
    const STRING_NON_C = '^C';
    const STRING_ABC   = 'ABC';
    const INT_A = 1;
    const INT_B = 2;

    /**
     * Is not allowed to call from outside to prevent from creating multiple instances,
     * to use the singleton, you have to obtain the instance from Singleton::getInstance() instead
     */
    protected function __construct() {
    }

    /**
     * Prevent from being cloned (which would create a second instance of it)
     *
     * @return void
     */
    protected function __clone() {
    }

    /**
     * Prevent from being unserialized (which would create a second instance of it)
     *
     * @return mixed
     * @throws Exception
     */
    public function __wakeup() {
        throw new \RuntimeException("Cannot unserialize singleton");
    }

    /**
     * Get a singleton instance
     * 
     * @return Singleton
     */
    public static function getInstance(): Singleton {
        if (!isset(self::$_instance)) {
            self::$_instance = new self();
        }

        return self::$_instance;
    }

    /**
     * Display user name
     *
     * @param string $name User-provided name
     * @return mixed|string
     */
    public function userEcho($name) {
        // Validate type and length
        if (!is_string($name) || !strlen($name)) {
            return 'Invalid user-provided name';
        }
        
        // The function should still echo the name
        echo filter_var($name, FILTER_SANITIZE_STRING);
    }

    /**
     * Query by user name
     *
     * @param string $name User-provided name
     */
    public function userQuery($name) {
        $mysqli = new mysqli('localhost', 'user', 'pass', 'my_database');
        
        // Don't change the query
        $stmt = $mysqli->prepare("SELECT * FROM `test` WHERE `name` = ? LIMIT 1");
        $stmt->bind_param("s", $name);
        $stmt->execute();
    }

    /**
     * Output the contents of a file
     *
     * @param string $path User-provided file path
     */
    public function userFile($path) {
        // User paths are relative to this root
        $root = '/real/path/to/files';
        
        // The main point is to never allow users to perform directory traversal
        // Special characters like "." and ".." and direct root access should be forbidden
        if (!is_string($path) || !strlen($path)) {
            throw new Exception('No file path provided');
        }
        
        // Validate relative path, file name and extension
        if (!preg_match('%^(?:allowed_path_a|allowed_path_b)\/\w+\.(?:ext|png|jpe?g)$%i', $path)) {
            throw new Exception('Invalid file path');
        }
        
        // File not found
        if (!is_file("$root/$path")) {
            throw new Exception('File not found');
        }
        
        // No need to assume headers
        readfile("$root/$path");
        // No need to assume the script ends here
    }

    /**
     * Nested conditions, untangle nested conditions
     *
     * @param $conditionA
     * @param $conditionB
     * @param $conditionC
     */
    public function nestedConditions($conditionA, $conditionB, $conditionC) {
        // Don't change return type
        // The function needs to echo strings, not return them
        // Don't introduce new constants
        do {
            if (!$conditionA) {
                echo self::STRING_NON_A;
                break;
            }
            
            if (!$conditionB) {
                echo self::STRING_NON_B;
                break;
            }
            
            if (!$conditionC) {
                echo self::STRING_NON_C;
                break;
            }
            
            echo self::STRING_ABC;
        } while(false);
    }

    /**
     * Return statements
     *
     * @param $conditionA
     * @return bool
     */
    public function returnStatements($conditionA) {
        // Don't alter the function behavior
        if ($conditionA) {
            echo self::STRING_A;
        }
        
        // Implicit boolean conversion
        return !!$conditionA;
    }

    /**
     * Null coalescing
     *
     * @return string
     */
    public function nullCoalescing() {
        return $_GET['name'] ?? $_POST['name'] ?? 'nobody';
    }

    /**
     * Method chaining
     *
     * @return $this
     */
    public function methodChained(): Singleton {
        return $this;
    }

    /**
     * Immutables are hard to find
     *
     * @param $value
     * @return mixed
     */
    public function checkValue($value) {
        $result = null;
        
        // We should't use constants (strings, ints) locally
        // Store them as class constants instead
        switch ($value) {
            case self::STRING_A_LONG:
                $result = INT_A;
                break;
                
            case self::STRING_B_LONG:
                $result = INT_B;
                break;
        }
        
        return $result;
    }
    
    /**
     * Check a string is a 24 hour time
     *
     * @example "00:00:00", "23:59:59", "20:15"
     * @param string $time24Hour 23 Hour time string
     * @return boolean
     */
    public function regexTest(string $time24Hour) {
        // No need to sanitize further, a regex will do
        // 0 left padding - so [01]\d instad of [01]?\d (02:00 instead of 2:00)
        // DRY - don't repeat yourself, the 00-59 minute/second block can appear once or twice
        // Don't user capturing blocks if you don't need them - (?:) instead of ()
        // preg_match returns 0,1 or false; expected return value is boolean
        return !!preg_match('#^(?:[01]\d|2[0-3])(:[0-5]\d){1,2}$#', $time24Hour);
    }

}
